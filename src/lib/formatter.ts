import * as path from "node:path";
import { highlight } from "cli-highlight";

export interface TextResult {
  path: string;
  score: number;
  content: string;
  chunk_type?: string;
  start_line: number;
  end_line: number;
}

const style = {
  bold: (s: string) => `\x1b[1m${s}\x1b[22m`,
  dim: (s: string) => `\x1b[2m${s}\x1b[22m`,
  green: (s: string) => `\x1b[32m${s}\x1b[39m`,
  blue: (s: string) => `\x1b[34m${s}\x1b[39m`,
};

function detectLanguage(filePath: string): string {
  const ext = path.extname(filePath).toLowerCase();
  switch (ext) {
    case ".ts":
    case ".tsx":
      return "typescript";
    case ".js":
    case ".jsx":
      return "javascript";
    case ".py":
      return "python";
    case ".rs":
      return "rust";
    case ".go":
      return "go";
    case ".java":
      return "java";
    case ".json":
      return "json";
    case ".md":
      return "markdown";
    case ".yml":
    case ".yaml":
      return "yaml";
    case ".css":
      return "css";
    case ".html":
      return "html";
    case ".sh":
      return "bash";
    default:
      return "plaintext";
  }
}

function cleanSnippetLines(snippet: string): string[] {
  const NOISE_PREFIXES = [
    "File:",
    "Top comments:",
    "Preamble:",
    "(anchor)",
    "Imports:",
    "Exports:",
    "---",
  ];

  return snippet
    .split("\n")
    .map((line) => {
      let next = line.trimEnd();
      // Strip inline metadata that sometimes gets glued onto code lines
      const fileIdx = next.indexOf("File:");
      if (fileIdx !== -1) {
        next = next.slice(0, fileIdx).trimEnd();
      }
      return next;
    })
    .filter((line) => {
      const trimmed = line.trim();
      if (!trimmed) return false;
      return !NOISE_PREFIXES.some((p) => trimmed.startsWith(p));
    })
    .map((line) => {
      const limit = 140;
      if (line.length <= limit) return line;
      return `${line.slice(0, limit)}${style.dim(" ...")}`;
    });
}

export function formatTextResults(
  results: TextResult[],
  query: string,
  root: string,
  isPlain: boolean
): string {
  if (results.length === 0) return `osgrep: No results found for "${query}".`;

  const fileGroups = new Map<string, TextResult[]>();
  results.forEach((r) => {
    const existing = fileGroups.get(r.path) || [];
    existing.push(r);
    fileGroups.set(r.path, existing);
  });
  const fileCount = fileGroups.size;

  // --- MODE A: AGENT (Hyper-Dense) ---
  // Goal: Max information density per token.
  if (isPlain) {
    let output = "";
    
    results.forEach((item) => {
      const relPath = path.relative(root, item.path);
      const line = Math.max(1, item.start_line + 1);
      
      // 1. Semantic Tags (The Agent's Guide)
      const tags: string[] = [];
      const type = item.chunk_type || "";
      if (type.match(/function|class|method/)) tags.push("Definition");
      if (relPath.includes("test") || relPath.includes("spec")) tags.push("Test");
      const tagStr = tags.length > 0 ? ` [${tags.join(",")}]` : "";

      output += `${relPath}:${line}${tagStr}\n`;
    });
    output += `osgrep results (${results.length} matches across ${fileCount} files)`;
    return output.trim();
  }

  // --- MODE B: HUMAN (Pretty) ---
  let output = `\n${style.bold(`osgrep results (query: "${query}", ${results.length} matches across ${fileCount} files)`)}\n`;
  let rank = 1;

  for (const [filePath, chunks] of fileGroups) {
    chunks.sort((a, b) => a.start_line - b.start_line);
    
    // Smart Stitching Logic
    const merged: TextResult[] = [];
    if (chunks.length > 0) {
        let current = chunks[0];
        for (let i = 1; i < chunks.length; i++) {
            const next = chunks[i];
            if (next.start_line <= current.end_line + 10) {
                current.content += `\n   // ...\n${next.content}`;
                current.end_line = next.end_line;
                if (next.chunk_type?.match(/function|class/)) current.chunk_type = next.chunk_type;
            } else {
                merged.push(current);
                current = next;
            }
        }
        merged.push(current);
    }

    const relPath = path.relative(root, filePath);
    for (const item of merged) {
      const tags: string[] = [];
      if (item.chunk_type?.match(/function|class/)) tags.push("Definition");
      const tagStr = tags.length > 0 ? ` ${style.blue(`[${tags.join(", ")}]`)}` : "";

      const line = Math.max(1, item.start_line + 1);
      const snippet = item.content
        .trim()
        .replace(/^File:.*\n/, "")
        .replace(/^Function:.*\n/, "")
        .trim();

      const lines = cleanSnippetLines(snippet);
      const maxLines = 12;
      const truncated =
        lines.length > maxLines
          ? [...lines.slice(0, maxLines), style.dim(`... (+${lines.length - maxLines} more lines)`)]
          : lines;

      // Apply syntax highlighting for humans
      let rendered = truncated.join("\n");
      try {
        const lang = detectLanguage(filePath);
        rendered = highlight(rendered, { language: lang, ignoreIllegals: true });
      } catch {
        // fall back to non-highlighted text
      }

      output += `${rank}) ðŸ“‚ ${style.green(relPath)}${style.dim(`:${line}`)}${tagStr}\n`;
      const numbered = rendered.split("\n").map((ln, idx) => {
        const num = style.dim(`${line + idx}`.padStart(4));
        return `${num} â”‚ ${ln}`;
      });
      numbered.forEach((ln) => {
        output += `${ln}\n`;
      });
      output += "\n";
      rank++;
    }
  }
  output += style.dim(`${results.length} matches across ${fileCount} files`);
  return output.trimEnd();
}
